<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Patrick Oyarzun</title>
    <link>https://poyarzun.io/index.xml</link>
    <description>Recent content on Patrick Oyarzun</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    <copyright>Patrick Oyarzun All rights reserved.</copyright>
    <lastBuildDate>Wed, 26 Oct 2016 20:03:39 -0400</lastBuildDate>
    <atom:link href="https://poyarzun.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Benchmarking (Benchmarking Elm Functions)</title>
      <link>https://poyarzun.io/blog/benchception/</link>
      <pubDate>Wed, 26 Oct 2016 20:03:39 -0400</pubDate>
      
      <guid>https://poyarzun.io/blog/benchception/</guid>
      <description>&lt;p&gt;In &lt;a href=&#34;https://poyarzun.io/blog/elm-bench/&#34;&gt;my last post&lt;/a&gt;, I released a benchmarking package for elm. I got some interesting feedback on reddit
from user ianmackenzie. What if my benchmarking package is adding significant overhead to the things it&amp;rsquo;s trying to benchmark?
I hadn&amp;rsquo;t made any particular effort to make it fast, so this is a great opportunity to try. As a matter of fact, I can use my
benchmark package to benchmark the new implementation. Let&amp;rsquo;s try it out.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s a complete demo app that uses the library to benchmark a new implementation of the &lt;code&gt;repeat&lt;/code&gt; function.
It essentially tries to benchmark the function &lt;code&gt;\() -&amp;gt; ()&lt;/code&gt;, which is the simplest possible function I could think of.
With any luck, the performance of the benchmarking tool should dominate.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;module Bootstrap exposing (..)

import Bench
import Html
import Html.App as App
import Time
import Task
import Process


type alias Model =
    { benchmarks : List ( String, Bench.Timing ) }


type Msg
    = BenchmarkDone String Bench.Timing
    | Noop


testFunc : () -&amp;gt; ()
testFunc () =
    ()


newRepeat : (() -&amp;gt; b) -&amp;gt; Int -&amp;gt; ()
newRepeat f n =
    if n &amp;lt;= 0 then
        ()
    else
        let
            _ =
                f ()
        in
            newRepeat f (n - 1)


main : Program Never
main =
    App.program
        { init =
            ( { benchmarks = [] }
            , Task.perform (\_ -&amp;gt; Noop) (\_ -&amp;gt; Noop) (Process.sleep (Time.millisecond * 1000))
            )
        , view = view
        , update = update
        , subscriptions = subscriptions
        }


view : Model -&amp;gt; Html.Html Msg
view model =
    let
        viewTiming ( name, timing ) =
            Html.div []
                [ Html.h1 [] [ Html.text name ]
                , Html.text (toString timing)
                ]
    in
        Html.div [] ((Html.text &amp;quot;Benchmarks will appear here:&amp;quot;) :: (List.map viewTiming model.benchmarks))


update : Msg -&amp;gt; Model -&amp;gt; ( Model, Cmd Msg )
update msg model =
    case msg of
        BenchmarkDone name timing -&amp;gt;
            ( { model | benchmarks = ( name, timing ) :: model.benchmarks }, Cmd.none )

        Noop -&amp;gt;
            ( model
            , Cmd.batch
                [ Bench.benchmark (BenchmarkDone &amp;quot;Current Implementation&amp;quot;) (Bench.repeat testFunc)
                , Bench.benchmark (BenchmarkDone &amp;quot;Proposed Implementation&amp;quot;) (newRepeat testFunc)
                ]
            )


subscriptions : Model -&amp;gt; Sub Msg
subscriptions model =
    Sub.none

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you run this app (and make sure to pin the version of elm-bench at 1.0.0), you should see that the
proposed implementation is around an order of magnitude faster! You can also check out the &lt;a href=&#34;https://poyarzun.io/apps/benchception&#34;&gt;live demo&lt;/a&gt;. As of now, the new implementation has
been merged in as the default. I&amp;rsquo;ve also added the benchmarking app as a sub module so you can easily
run small tests like this one. The &lt;a href=&#34;http://package.elm-lang.org/packages/Logiraptor/elm-bench/latest&#34;&gt;documentation is available on package.elm-lang.org&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Thanks for reading!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Benchmarking Elm Functions</title>
      <link>https://poyarzun.io/blog/elm-bench/</link>
      <pubDate>Sun, 23 Oct 2016 20:38:55 -0400</pubDate>
      
      <guid>https://poyarzun.io/blog/elm-bench/</guid>
      <description>

&lt;h2 id=&#34;background&#34;&gt;Background&lt;/h2&gt;

&lt;p&gt;I come from a background of mostly Go development. One thing I&amp;rsquo;ve missed since starting
to write Elm code is the lack of a good benchmarking tool like the one in Go&amp;rsquo;s standard library.
Porting the core of it to Elm was a good opportunity to learn about Elm&amp;rsquo;s Task system.
You can find &lt;a href=&#34;http://package.elm-lang.org/packages/Logiraptor/elm-bench/latest&#34;&gt;docs for the latest version of the code&lt;/a&gt; in the elm package repository.&lt;/p&gt;

&lt;h2 id=&#34;usage&#34;&gt;Usage&lt;/h2&gt;

&lt;p&gt;The core API of the package is a single function:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
benchmark : (Timing -&amp;gt; msg) -&amp;gt; (Int -&amp;gt; a) -&amp;gt; Cmd msg

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The arguments, in order, are:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;a message constructor so benchmark can dispatch a Msg back to your app when the benchmark is finished.&lt;/li&gt;
&lt;li&gt;the function to be profiled.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;You&amp;rsquo;re probably wondering why the type for your function must be &lt;code&gt;Int -&amp;gt; a&lt;/code&gt;.
In order to reliably time a function which we know nothing about, we need to execute it many times. If the function is slow, maybe once is enough.
If the function is fast, we need to execute it lots and lots of times in order to get a reliable result.
So, in order to execute an arbitrary computation N times, it&amp;rsquo;s best to just pass N to the caller and let
them decide what&amp;rsquo;s best. This gives the user of the library the most control in deciding how their code
gets scaled up for performance testing. However, many times you won&amp;rsquo;t want to do anything special,
you just want to execute the same code over and over until the benchmark is reliable. In that case, there is a second function:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
repeat : (() -&amp;gt; a) -&amp;gt; Int -&amp;gt; ()

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The repeat function takes and arbirary function and converts it into a form that benchmark can use. This way, if you just want to take the easy path,
all you have to do is wrap your function in &lt;code&gt;repeat&lt;/code&gt; and you&amp;rsquo;re good to go.&lt;/p&gt;

&lt;p&gt;With just these basic building blocks, we can write the following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;module Main exposing(..)

...
import Bench

type Msg = 
    BenchmarkComplete Bench.Timing

type alias Model =
    { benchmark : Bench.Timing }

update : Msg -&amp;gt; Model -&amp;gt; Model
update msg model =
    case msg of
        BenchmarkComplete timing -&amp;gt;
            { model | benchmark = timing }

startBenchmark : Cmd Msg
startBenchmark =
    Bench.benchmark BenchmarkComplete (Bench.repeat (\() -&amp;gt; &amp;quot;a&amp;quot; + &amp;quot;b&amp;quot;))

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now if we return startBenchmark to the system as a command, we will receive the results in our
update function when it&amp;rsquo;s complete. In this case, we are benchmarking the time taken to append
two strings. In reality, the compiler will likely optimize the concatenation into a noop, but this is the general idea.&lt;/p&gt;

&lt;p&gt;This is the first elm package I&amp;rsquo;ve published publicly, so I&amp;rsquo;d love to hear your feedback!&lt;/p&gt;

&lt;p&gt;Update: &lt;a href=&#34;https://poyarzun.io/blog/benchception&#34;&gt;I benchmarked elm-bench using elm-bench!&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>The Future of Development (If I get my way)</title>
      <link>https://poyarzun.io/blog/future/</link>
      <pubDate>Sat, 21 May 2016 09:38:47 -0400</pubDate>
      
      <guid>https://poyarzun.io/blog/future/</guid>
      <description>&lt;p&gt;&lt;strong&gt;These ideas are very incomplete, but I&amp;rsquo;ll never publish them if I wait for that&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve been thinking about this for a couple years now, and it&amp;rsquo;s about time I write some of my ideas down. What I&amp;rsquo;m talking about is the proliferation of so called &amp;lsquo;codeless&amp;rsquo; tools. These are tools that allow you to build real, working applications without writing a single line of code. I believe in these tools. For context, I have been writing code professionally for about 5 years now, and non professionally for 11 years. I love programming and I don&amp;rsquo;t want to see it go. However, we want more software, and we need more people to build it. There are several ways to solve this problem:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Teach more people to code&lt;/li&gt;
&lt;li&gt;Make coding easier&lt;/li&gt;
&lt;li&gt;Something more creative&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;I haven&amp;rsquo;t come up with an answer for 3 yet, and lots of people are working on number 1. Let&amp;rsquo;s talk about number 2.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ve come a long long way from where we began. New languages and tools have allowed huge new waves of people to become programmers by lowering the barrier to entry. I believe there is much more work to be done before we&amp;rsquo;ve exhausted our options.&lt;/p&gt;

&lt;p&gt;I think it&amp;rsquo;s time we consider graphical programming as a serious solution to most application development. When I tell people this, especially other developers, the typical reaction is something like &amp;ldquo;We tried that and it sucked, it&amp;rsquo;s a waste of time&amp;rdquo;. They cite things like visual basic and smalltalk as examples of failed attempts in the past. I agree that tools of the past and many existing tools are lacking in one way or another. However, I don&amp;rsquo;t believe that there is any fundamental reason why application development can&amp;rsquo;t be accessible to everyone.&lt;/p&gt;

&lt;p&gt;In software, there are two forms of complexity: incidental complexity, and domain complexity. Domain complexity is the complexity that comes from the problem you&amp;rsquo;re trying to solve. Incidental complexity just appears out of nowhere based on how you choose to solve the problem. For example, if I want to build a twitter clone, I have to worry about users, tweets, and a few other things at a minimum. There is no fundamental reason why I should have to understand the subtle rules around how css rules are applied or how to provision a vm on aws. Yet somehow, as application developers we deal with these problems every day. Sure, in practice it&amp;rsquo;s really not that big of a deal because we&amp;rsquo;ve learned to avoid problems ahead of time with &lt;em&gt;design patterns&lt;/em&gt;. My question to other developers is this: &lt;strong&gt;Why did I have to spend the first few years of my programming experience just learning what to avoid?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;This feeling is only made stronger by the fact that most routine work I do involves redoing work that has been done hundred or thousands of times before. At this point in my career, I&amp;rsquo;ve implemented something like 5-8 complete authentication flows. This means register, login, logout, forgot password, etc. In some cases, it was easy because I used devise in a rails project. In other cases it was hard because I didn&amp;rsquo;t have a web app framework to support me, and thus had to implement it mostly from scratch. In reality, authentication is complex and difficult to get right, but there are clear best practices around user experience and security. I wish that all I had to do was toggle a checkbox in order to enable authentication in my app. Am I being overly optimistic? I don&amp;rsquo;t think so. Imagine for a moment the state of software development in the year 2500. Are we still writing code in plain text files and sending them through a program to convert it into something useful? Do we still deal with dependency hell? In my vision of the future, the answer is no.&lt;/p&gt;

&lt;p&gt;I don&amp;rsquo;t claim to have any real solutions to this problem, but I would like to make a call to the open source community to start thinking and talking about this.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Check: Experimental type checker for reflection heavy Go programs</title>
      <link>https://poyarzun.io/blog/check/</link>
      <pubDate>Mon, 09 Feb 2015 20:29:22 -0500</pubDate>
      
      <guid>https://poyarzun.io/blog/check/</guid>
      <description>

&lt;p&gt;Before getting into the content of this post, I&amp;rsquo;d like to make something clear. Don&amp;rsquo;t use this in production. I&amp;rsquo;m not even sure this is a good idea, but it&amp;rsquo;s an idea I&amp;rsquo;ve had for a while.&lt;/p&gt;

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;Go doesn&amp;rsquo;t have a lot of things. It&amp;rsquo;s very spartan in that way. I think it&amp;rsquo;s a good thing, but when reading about Go you will unavoidably find people who disagree. I&amp;rsquo;m not going to talk about that because there are tons of articles and blog posts which discuss the issue at great length. The goal here is to see what is possible with Go in its current state.&lt;/p&gt;

&lt;p&gt;So, how do I write the classic map function in Go? If you ask someone who has embraced Go&amp;rsquo;s style, the answer will probably be &amp;ldquo;use a for loop&amp;rdquo;. For example, if you want the equivalent of Python&amp;rsquo;s &lt;code&gt;map(lambda x: x*x, [1,2,3])&lt;/code&gt;, you might write:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;var input = []int {1, 2, 3}
var output = make([]int, len(input))

for i, x := range input {
	output[i] = x * x
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s that simple. There is no question of what this code does, and anyone with a decent understanding of programming can immediately read and understand it. But what if we don&amp;rsquo;t care and we want to be able to write this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;output := Map(func(i int) int {
	return i * i
}, []int{1, 2, 3})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Well, we can. Define Map like so:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;func Map(fn func(int)int, in []int) []int {
	out := make([]int, len(in))
	for i, x := range in {
		out[i] = fn(x)
	}
	return out
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This feels like cheating though, because we can&amp;rsquo;t use that function with anything but ints. We can achieve a fully &amp;ldquo;generic&amp;rdquo; solution with reflection like so:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;import &amp;quot;github.com/Logiraptor/fun&amp;quot;

func Map(fn interface{}, arr interface{}) interface{} {
	types := fun.Check(func(func(fun.A) fun.B, []fun.A) {}, fn, arr)
	outType := types[fun.BKey]

	output := reflect.New(reflect.SliceOf(outType)).Elem()
	funV := reflect.ValueOf(fn)
	slice := reflect.ValueOf(arr)
	length := slice.Len()
	for i := 0; i &amp;lt; length; i++ {
		x := funV.Call([]reflect.Value{slice.Index(i)})[0]
		output = reflect.Append(output, x)
	}

	return output.Interface()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s a bit longer, and we&amp;rsquo;ve thrown type safety out the window, but we can almost write the code we wanted. The call to &lt;code&gt;fun.Check&lt;/code&gt; is another bit of reflection code that does simple template-style type checking at runtime. These will all compile just fine now:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Go&#34;&gt;// =&amp;gt; [1, 4, 9]
output := Map(func(i int) int {
	return i * i
}, []int{1, 2, 3}).([]int)

// =&amp;gt; [0, 3, 2]
output := Map(func(s string) int {
	return len(s)
}, []string{&amp;quot;&amp;quot;, &amp;quot;foo&amp;quot;, &amp;quot;go&amp;quot;}).([]int)

// uh-oh...
output := Map(func(s string) int {
	return len(s)
}, []int{1, 2, 3}).([]int)

Map(true, &amp;quot;panic&amp;quot;)
Map(&amp;quot;no type checking&amp;quot;, 78)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice that by using reflection, we&amp;rsquo;ve lost the ability to check types statically. The last 3 invocations will panic at runtime with a less than readable error. For me, static typing is a &lt;strong&gt;huge&lt;/strong&gt; reason why I&amp;rsquo;m productive in Go. The task before us is to get back some static verification without changing the Go language at all. So that&amp;rsquo;s what I did. I have a toy program called check which can look at that program and tell me statically that the &lt;code&gt;func(string) int&lt;/code&gt; doesn&amp;rsquo;t match the &lt;code&gt;[]int&lt;/code&gt;. It&amp;rsquo;s ~200 lines of Go apart from the standard library + tools. It makes extensive use of &lt;code&gt;go/types&lt;/code&gt; for the actual work, and it&amp;rsquo;s actually surprisingly general. To use it, you just run &lt;code&gt;check &amp;quot;Map(func(A)B, []A)&amp;quot;&lt;/code&gt;. Or, if you want to be hip, you can use &lt;code&gt;go generate&lt;/code&gt; like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//go:generate check &amp;quot;Map(func(A)B, []A)&amp;quot;

// We can check reduce too!
//go:generate check &amp;quot;Reduce(func(A, B) A, A, []B)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Check will parse &amp;ldquo;Map(func(A)B, []A)&amp;rdquo; and treat A and B as type variables which can be unified with any other type. Of course, all instances of a specific type variable must unify with the same type.&lt;/p&gt;

&lt;h2 id=&#34;limitations&#34;&gt;Limitations&lt;/h2&gt;

&lt;p&gt;I feel the need to repeat: this is just a toy program to experiment with writing my first static analysis tool. It&amp;rsquo;s probably a terrible idea in the first place. These are the problems I see with it:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The function (e.g. Map) must be defined locally.&lt;/li&gt;
&lt;li&gt;It doesn&amp;rsquo;t verify the result type so a nested Map call will not type check properly.&lt;/li&gt;
&lt;li&gt;The function name must be unique among all call expressions in the entire program. So, you can&amp;rsquo;t call &lt;code&gt;other.Map&lt;/code&gt; without it trying to type check that as well.&lt;/li&gt;
&lt;li&gt;Since it&amp;rsquo;s not part of the compiler, it&amp;rsquo;s not guaranteed to run before compilation.&lt;/li&gt;
&lt;li&gt;This is classic overuse of reflection.&lt;/li&gt;
&lt;li&gt;check is not a very creative name.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;I think the coolest part of all this is that I was able to write this whole thing while taking notes at my university in 3 days. I see it as a testament to the standard library that it&amp;rsquo;s so short and so easy to do.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Writing a LISP Interpreter in Go</title>
      <link>https://poyarzun.io/blog/lisp/</link>
      <pubDate>Fri, 28 Feb 2014 20:29:22 -0500</pubDate>
      
      <guid>https://poyarzun.io/blog/lisp/</guid>
      <description>&lt;p&gt;I&amp;rsquo;ve wanted to write my own programming language since I started programming in highschool, but it always seemed impossible. I thought only the mythical wizards of the internet could actually forge their own language as a hobby. 5 years later and it turns out it&amp;rsquo;s &lt;a href=&#34;http://norvig.com/lispy.html&#34;&gt;not&lt;/a&gt; &lt;a href=&#34;http://bobappleyard.wordpress.com/2010/02/18/writing-a-lisp-interpreter-in-go/&#34;&gt;that&lt;/a&gt; &lt;a href=&#34;http://www.essenceandartifact.com/2012/09/how-to-create-turing-complete.html&#34;&gt;hard&lt;/a&gt;. (I didn&amp;rsquo;t find that second one until after I had finished).&lt;/p&gt;

&lt;p&gt;I tried my hand at writing a few mini-languages, but they always felt over complicated for the small feature set they offered. I remembered reading that LISPs are super easy to parse and so decided that would be my next project, but first I needed to generalize this whole idea of parsing. I stumbled upon &lt;a href=&#34;http://en.wikipedia.org/wiki/Parsing_expression_grammar&#34;&gt;parsing expression grammars&lt;/a&gt; and I was off. I wrote a peg parser over the weekend to make my life easier on future projects, which you can find &lt;a href=&#34;https://github.com/Logiraptor/chicken&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Ok! Enough talking, here&amp;rsquo;s the grammar for my LISP:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;prgm &amp;lt;- list+
list &amp;lt;- _?^ open atom_left+ close
atom_left &amp;lt;- atom _?^
atom &amp;lt;- number / name / list
name &amp;lt;- ~&#39;[a-zA-Z/\-\*\+=&amp;gt;&amp;lt;]+&#39;
number &amp;lt;- ~&#39;-?\d+\.?\d*&#39;
open &amp;lt;- &#39;(&#39;
close &amp;lt;- &#39;)&#39;
_ &amp;lt;- ~&#39;\s+&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So basically, there are two fundamental parts, numbers and names. Each are defined by regular expressions. The &lt;code&gt;~&lt;/code&gt; denotes a regex in my peg parser. Everything else is pretty simple, aside from the &lt;code&gt;^&lt;/code&gt; operator. A rule followed by &lt;code&gt;^&lt;/code&gt; will be consumed from input normally, but will be discarded from the parse tree that is ultimately generated. Note that I use it to explicitly ignore whitespace between items in a list. This is not technically necessary, but it makes the interpreter a little cleaner since we can worry only about the stuff we care about.&lt;/p&gt;

&lt;p&gt;In order to evaluate the parse tree we need to transform it into some internal representation we can process easily. Go is strongly typed, so let&amp;rsquo;s define some types to hold our program.
&lt;pre&gt;&lt;code&gt;type Atom interface{}
type List []Atom
type Number float64
type Symbol string
type Bool bool
&lt;/code&gt;&lt;/pre&gt;

We&amp;rsquo;ll take the easy way out and have only one type of number, &lt;code&gt;float64&lt;/code&gt;. Javascript has made it this far, so it should do for a weekend project. Note that the Symbol type is not actually a string datatype. Symbol is used for a variable or function identifier, and it&amp;rsquo;s internal representation is a Go string. The lisp does not support actual string values because that would complicate the grammar a bit and I wanted to keep it as simple as possible for the first real test of my peg library. One other interesting result is that &lt;code&gt;List&lt;/code&gt; is automatically also an &lt;code&gt;Atom&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Now the transformation function:
&lt;pre&gt;&lt;code&gt;func transformPRGM(p *peg.ParseTree, out chan List) {
    for _, child := range p.Children {
        out &amp;lt;- transform(child).(List)
    }
    close(out)
}

func transform(p *peg.ParseTree) Atom {
    switch p.Type {
    case &#34;number&#34;:
        val, err := strconv.ParseFloat(string(p.Data), 64)
        if err != nil {
            panic(err)
        }
        return Number(val)
    case &#34;name&#34;:
        return Symbol(string(p.Data))
    case &#34;list&#34;:
        var resp = make(List, len(p.Children[1].Children))
        for i, child := range p.Children[1].Children {
            resp[i] = transform(child)
        }
        return resp
    default:
        fmt.Println(p)
        panic(fmt.Sprintf(&#34;Cannot transform %s&#34;, p.Type))
    }
}
&lt;/code&gt;&lt;/pre&gt;

We see that the parse tree fills in a Type string on each node based on the rule that it satisfies, so we can just switch on that to determine the proper type to return. Also, we know that any number we encounter is a valid float because it satisfied the regular expression, so we panic on error instead of returning one since it should be a very rare case and I think can only be caused if the number literal is too big for a &lt;code&gt;float64&lt;/code&gt; to represent. That&amp;rsquo;s huge.&lt;/p&gt;

&lt;p&gt;Now that we have an internal representation, all we need are a few built-in functions and an eval function. We&amp;rsquo;ll define the execution environment as follows:
&lt;pre&gt;&lt;code&gt;type Env struct {
    mapping map[Symbol]Atom
    outer   *Env
}

func (e *Env) find(s Symbol) map[Symbol]Atom {
    if _, ok := e.mapping[s]; ok {
        return e.mapping
    } else if e.outer != nil {
        return e.outer.find(s)
    } else {
        return nil
    }
}

type FuncLit func(List) (Atom, error)

func (f FuncLit) Call(l List) (Atom, error) {
    return f(l)
}

type Procedure struct {
    params List
    body   Atom
    env    *Env
}

func (p *Procedure) Call(l List) (Atom, error) {
    return nil, fmt.Errorf(&#34;procedure call: tail recursion is required&#34;)
}

type Func interface {
    Call(List) (Atom, error)
}
&lt;/code&gt;&lt;/pre&gt;

The purpose of &lt;code&gt;Env&lt;/code&gt; is to manage function and variable bindings and also provides lexical scoping through the &lt;code&gt;find&lt;/code&gt; method. We also define types for user-defined functions through Procedure, and Go defined functions through FuncLit. All that&amp;rsquo;s left is eval!
&lt;pre&gt;&lt;code&gt;var QUOTE Symbol = &#34;quote&#34;
var IF Symbol = &#34;if&#34;
var SET Symbol = &#34;set&#34;
var DEFINE Symbol = &#34;define&#34;
var LAMBDA Symbol = &#34;lambda&#34;
var BEGIN Symbol = &#34;begin&#34;

func eval(a Atom, e *Env) (Atom, error) {
    var err error
    for {
        switch a.(type) {
        case Number:
            return a, nil
        case Symbol:
            s := a.(Symbol)
            return e.find(s)[s], nil
        case List:
            l := a.(List)
            switch l[0] {
            case QUOTE:
                return l[1], nil
            case IF:
                test, conseq, alt := l[1], l[2], l[3]
                t, err := eval(test, e)
                if err != nil {
                    return nil, err
                }
                if t.(Bool) {
                    a = conseq
                } else {
                    a = alt
                }
            case SET:
                name, exp := l[1].(Symbol), l[2]
                e.find(name)[name], err = eval(exp, e)
                return nil, err
            case DEFINE:
                name, exp := l[1].(Symbol), l[2]
                e.mapping[name], err = eval(exp, e)
                return nil, err
            case LAMBDA:
                vars, exp := l[1].(List), l[2]
                return &amp;amp;Procedure{
                    vars, exp, e,
                }, nil
            case BEGIN:
                for _, exp := range l[1 : len(l)-1] {
                    _, err = eval(exp, e)
                    if err != nil {
                        return nil, err
                    }
                }
                a = l[len(l)-1]
            default:
                exps := make([]Atom, len(l))
                for i, exp := range l {
                    exps[i], err = eval(exp, e)
                    if err != nil {
                        return nil, err
                    }
                }
                proc := exps[0].(Func)
                if p, ok := proc.(*Procedure); ok {
                    a = p.body
                    e = NewEnvFrom(p.params, exps[1:], p.env)
                } else {
                    x, err := proc.Call(exps[1:])
                    if err != nil {
                        return nil, fmt.Errorf(&#34;%s: %s&#34;, l[0], err)
                    }
                    return x, nil
                }
            }
        default:
            panic(fmt.Sprintf(&#34;Cannot eval %v&#34;, a))
        }
    }
    return nil, nil
}
&lt;/code&gt;&lt;/pre&gt;

Here you see the built-in functions quote, if, set, define, lambda, and begin. We&amp;rsquo;ve even got tail recursion! We can use these to define others. I&amp;rsquo;ve defined arithmetic with Go functions using my &lt;a href=&#34;https://github.com/Logiraptor/reflect&#34;&gt;wrapper&lt;/a&gt; which makes any function &amp;ldquo;generic&amp;rdquo;, but that uses Go reflection and is outside the scope of this post.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ll end with a sample of some code defined in the LISP and a benchmark against Go to show performance. (Hint, it&amp;rsquo;s terrible, but ok for a weekend and my first time ever writing code in a LISP).
&lt;pre&gt;&lt;code&gt;(define factorial
  (lambda (n)
    (if (= n 0) 1
        (* n (factorial (- n 1))))))
(factorial 100)
&lt;/code&gt;&lt;/pre&gt;

And the benchmark:
&lt;pre&gt;&lt;code&gt;PASS
BenchmarkGoFact  5000000           648 ns/op
BenchmarkCLISPFact     20000         96744 ns/op
ok      github.com/Logiraptor/chickenLISP   6.821s
&lt;/code&gt;&lt;/pre&gt;

That&amp;rsquo;s all for now. Full source with tests/benchmark is available &lt;a href=&#34;https://github.com/Logiraptor/chickenLISP&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>